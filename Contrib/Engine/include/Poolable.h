#pragma once

#include <assert.h>

/// Базовый класс для объектов, которые хотят пользоваться
/// не стандартным диспетчером кучи, а специализированным
/// под этот вид объектов.
///
/// Принцип использования памяти: при необходимости
/// память берётся у системного диспетчера кучи,
/// но никогда не отдаётся. Поэтому наследовать
/// от Poolable рекомендуется только те объекты,
/// память из-под которых не жалко не вернуть системе.
///
/// Предметы объединяются в списки в соответствии
/// с размером экземпляра - каждому размеру свой список.
///
/// Класс не содержит нестатических полей и не имеет
/// виртуальных функций (в том числе деструктора),
/// чтобы не влиять на потребление памяти потомками.
/// Это важно для каких-нибудь простеньких
/// структур вроде Object::LinkInfo.
///
/// По той же причине (ради Object::LinkInfo)
/// функциональность Poolable не встроена в Object.
///
/// Внимание! В случае наследования от класса без виртуального
/// деструктора могут побежать глюки (небольшие), ибо delete
/// может получать неверный размер удаляемого объекта
/// (меньший, потому и глюки небольшие).
/// Решает проблему правило: использовать
/// или нерасширяемые структуры (вроде Object::LinkInfo),
/// или наследовать от Interface с виртуальным деструктором.
///
/// Паттерн Singleton не используется, поскольку
/// для начала работы не требуется инициализация
/// статических объектов, только нулевое значение
/// глобальных (статических) переменных при запуске.
///
/// Бьерн Страуструп, Язык программирования C++,
/// специальное издание, $4.9.5, страница 122: "Если
/// инициализатор не задан, то глобальным объектам ($4.9.4),
/// объектам из пространства имён ($8.2) и локальным
/// статическим объектам ($7.1.2, $10.2.4) (все вместе
/// они называются /статическими объектами/)
/// присваивается нулевое значение соответствующего типа.
class Poolable
{
private:

	/// На какой размер потомков рассчитываем.
	/// Потребуется больше - нужно увеличить.
	///
	/// Для обеспечения многопоточности
	/// нужно сделать равным sizeof(void*).
	static const size_t BIG_SIZE = 2048;

	/// Количество объектов в одном сегменте,
	/// запрашиваемом у стандартного диспетчера кучи.
	static const int CHUNK_SIZE = 64;

	/// Значение байта, которым заполняется
	/// выделяемая область. В стиле Явы - 0,
	/// в стиле MS VS Debug - 0xCD.
	static const int NEW_FILL_VALUE = 0;

	/// Значение байта, которым заполняется
	/// почти вся освобождённая область.
	/// MS VS Debug заполняет двухбайтовыми целыми 0xFEEE.
	static const int DELETE_FILL_VALUE = 0xFE;

	/// Метод-обёртка, позволяющий не требовать объявления
	/// статического поля класса в cpp-файле.
	///
	/// Сама переменная: массив из указателей на однонаправленные
	/// списки (стеки) свободных блоков. Индекс - размер блока.
	static void ** Heads();

public:

	/// Перегруженный оператор new класса.
	void * operator new(std::size_t size);

	/// Перегруженный оператор delete класса.
	/// Система передаёт: rawMemory - указатель на место,
	/// где был объект (деструктор уже вызван),
	/// size - размер удаляемого объекта.
	void operator delete(void *rawMemory, std::size_t size);
};
